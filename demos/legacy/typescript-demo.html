<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>TypeScript & JSX Demo - Monaco Recorder</title>
    <style>
      html, body { height: 100%; margin: 0; font-family: -apple-system, sans-serif; background: #1e1e1e; color: #f0f0f0; }
      #toolbar { padding: 8px; border-bottom: 1px solid #444; display: flex; gap: 8px; align-items: center; flex-wrap: wrap; }
      #editor { position: absolute; top: 48px; bottom: 0; left: 0; right: 0; }
      button { background: #4a90e2; color: white; border: none; padding: 5px 10px; border-radius: 4px; cursor: pointer; }
      button:disabled { background: #555; color: #aaa; cursor: not-allowed; }
      .btn-group { display: flex; gap: 4px; margin-right: 8px; }
      .demo-selector { margin-left: auto; margin-right: 12px; }
      select, input { background: #2a2a2a; color: #f0f0f0; border: 1px solid #444; border-radius: 4px; padding: 4px 8px; }
    </style>
    <script>
      // Load Monaco via AMD loader
      const script = document.createElement('script');
      script.src = 'https://unpkg.com/monaco-editor@0.45.0/min/vs/loader.js';
      script.onload = () => {
        // Configure AMD paths
        window.require.config({ 
          paths: { 
            vs: 'https://unpkg.com/monaco-editor@0.45.0/min/vs',
            'vs/language/typescript': 'https://unpkg.com/monaco-editor@0.45.0/min/vs/language/typescript'
          }
        });
        // Ensure workers resolve correctly
        window.MonacoEnvironment = {
          getWorkerUrl: function(moduleId, label) {
            const base = 'https://unpkg.com/monaco-editor@0.45.0/min/vs';
            if (label === 'typescript' || label === 'javascript') {
              return `${base}/language/typescript/ts.worker.js`;
            }
            return `${base}/base/worker/workerMain.js`;
          }
        };
        window.require(['vs/editor/editor.main'], () => {
          // Monaco is now loaded and available globally
          window.monacoLoaded = true;
          // Notify that Monaco is ready
          document.dispatchEvent(new Event('monaco-loaded'));
        });
      };
      document.head.appendChild(script);
    </script>
  </head>
  <body>
    <div id="toolbar">
      <div class="controls">
        <button id="recordBtn" disabled>‚è∫ Start Recording</button>
        <button id="playBtn" disabled>‚ñ∂ Play</button>
        <button id="stopBtn" disabled>‚èπ Stop</button>
        <button id="exportBtn" disabled>üíæ Export</button>
        <div class="playback-controls">
          <label>Speed: <input id="speedRange" type="range" min="10" max="400" value="100"></label>
          <span id="speedValue">1.0x</span>
          <label>Threshold: <input type="number" id="thresholdInput" value="1000" min="0" max="5000" step="100"></label>
        </div>
      </div>
      <div class="demo-selector">
        <select id="demoSelect">
          <option value="">Select a demo...</option>
          <option value="typescript">TypeScript Features</option>
          <option value="jsx">React JSX</option>
          <option value="refactoring">Refactoring</option>
        </select>
      </div>
      
    </div>
    <div id="editor"></div>

    <script type="module">
      import { createMonacoRecorder, serializeEvents, deserializeEvents } from '../monaco-recorder.js';

      let editor = null;
      let recorder = null;
      let isRecording = false;
      let isPlaying = false;
      let loadedEvents = null; // events loaded from recordings/samples
      
      // Wait for Monaco to be loaded and initialize the editor
      document.addEventListener('monaco-loaded', () => {
        setupEditor();
      });
      
      // If Monaco is already loaded, trigger the event
      if (window.monacoLoaded) {
        document.dispatchEvent(new Event('monaco-loaded'));
      }
      
      const demos = {
        typescript: `// TypeScript Demo
interface User {
  id: number;
  name: string;
  role: 'admin' | 'user';
  lastLogin?: Date;
}

class UserManager {
  private users: User[] = [];
  
  addUser(user: Omit<User, 'id'>) {
    const newUser = { ...user, id: Date.now() };
    this.users.push(newUser);
    return newUser;
  }
  
  findUsers(predicate: (user: User) => boolean) {
    return this.users.filter(predicate);
  }
}

// Example usage
const manager = new UserManager();
manager.addUser({ name: 'Admin', role: 'admin' });
`,
        jsx: `// React JSX Demo
import React, { useState } from 'react';

interface Todo {
  id: number;
  text: string;
  completed: boolean;
}

const TodoApp: React.FC = () => {
  const [todos, setTodos] = useState<Todo[]>([]);
  const [input, setInput] = useState('');

  const addTodo = (e: React.FormEvent) => {
    e.preventDefault();
    if (!input.trim()) return;
    
    setTodos([...todos, {
      id: Date.now(),
      text: input,
      completed: false
    }]);
    setInput('');
  };

  return (
    <div className="todo-app">
      <h1>Todo App</h1>
      <form onSubmit={addTodo}>
        <input
          value={input}
          onChange={(e) => setInput(e.target.value)}
          placeholder="Add a todo..."
        />
        <button type="submit">Add</button>
      </form>
      <ul>
        {todos.map(todo => (
          <li key={todo.id}>
            <input
              type="checkbox"
              checked={todo.completed}
              onChange={() => {}}
            />
            {todo.text}
          </li>
        ))}
      </ul>
    </div>
  );
};
`,
        refactoring: `// Refactoring Demo
// Try right-clicking on functions and variables
// to see refactoring options

function calculateTotal(items) {
  let total = 0;
  for (let i = 0; i < items.length; i++) {
    total += items[i].price * items[i].quantity;
  }
  return total;
}

// Extract interface for better type safety
// Select the object literal below and use 'Extract to interface'
const product = {
  id: 1,
  name: 'Laptop',
  price: 999.99,
  inStock: true
};

// Convert to arrow function
function greet(name) {
  return 'Hello, ' + name + '!';
}
`
      };

      function setupEditor() {
        // Create a TS model with a .ts URI so TS-specific syntax works
        const initial = '// Select a demo from the dropdown above\n';
        const model = window.monaco.editor.createModel(
          initial,
          'typescript',
          window.monaco.Uri.parse('file:///demo.ts')
        );

        // Create editor with the model
        editor = window.monaco.editor.create(document.getElementById('editor'), {
          model,
          theme: 'vs-dark',
          minimap: { enabled: true },
          automaticLayout: true
        });

        // Initialize recorder
        recorder = createMonacoRecorder(editor, window.monaco, {
          onStart: () => {
            isRecording = true;
            updateUI();
          },
          onStop: () => {
            isRecording = false;
            updateUI();
          }
        });

        // Setup UI
        setupUI();
      }

      function setupUI() {
const recordBtn = document.getElementById('recordBtn');
const playBtn = document.getElementById('playBtn');
const stopBtn = document.getElementById('stopBtn');
const exportBtn = document.getElementById('exportBtn');
const demoSelect = document.getElementById('demoSelect');
const speedRange = document.getElementById('speedRange');
const speedValue = document.getElementById('speedValue');
const thresholdInput = document.getElementById('thresholdInput');

// Enable buttons
recordBtn.disabled = false;
playBtn.disabled = true;
stopBtn.disabled = true;
exportBtn.disabled = true;
demoSelect.disabled = false;

// Event listeners
recordBtn.addEventListener('click', () => {
if (isRecording) {
recorder.stop();
recordBtn.textContent = '‚è∫ Start Recording';
} else {
recorder.start();
recordBtn.textContent = '‚èπ Stop Recording';
}
updateUI();
});

playBtn.addEventListener('click', () => {
if (isPlaying) {
recorder.stopPlayback();
isPlaying = false;
updateUI();
return;
}
const speed = (parseInt(speedRange.value, 10) || 100) / 100;
const threshold = parseInt(thresholdInput.value) || 1000;
isPlaying = true;
updateUI();
const events = (loadedEvents && loadedEvents.length) ? loadedEvents : undefined;
recorder.play(events, {
speed,
minDelayMs: 0,
maxDelayMs: threshold,
onDone: () => {
isPlaying = false;
updateUI();
}
});
});

stopBtn.addEventListener('click', () => {
recorder.stopPlayback();
// Ensure local state reflects stop
isPlaying = false;
updateUI();
});

exportBtn.addEventListener('click', () => {
const events = recorder.getEvents();
if (!events || events.length === 0) return;
const serialized = serializeEvents(events);
const blob = new Blob([serialized], { type: 'application/json' });
const url = URL.createObjectURL(blob);
const a = document.createElement('a');
a.href = url;
a.download = 'monaco-recording.json';
document.body.appendChild(a);
a.click();
document.body.removeChild(a);
URL.revokeObjectURL(url);
});

        demoSelect.addEventListener('change', async (e) => {
          const demo = e.target.value;
          loadedEvents = null;
          if (demo && demos[demo]) {
            editor.setValue(demos[demo]);
          }
          // Attempt to load a matching recording file
          try {
            let file = null;
            if (demo === 'typescript') file = '../recordings/samples/typescript.json';
            else if (demo === 'jsx' || demo === 'react') file = '../recordings/samples/react.json';
            // 'refactoring' does not have a sample; leave loadedEvents null
            if (file) {
              const res = await fetch(file);
              if (res.ok) {
                const json = await res.json();
                // Support both raw array and {events}
                loadedEvents = Array.isArray(json) ? json : (json.events || null);
              }
            }
          } catch (err) {
            console.warn('Failed to load sample recording:', err);
            loadedEvents = null;
          }
          updateUI();
        });

        // Slider updates display
        speedRange.addEventListener('input', () => {
          const s = (parseInt(speedRange.value, 10) || 100) / 100;
          speedValue.textContent = `${s.toFixed(1)}x`;
        });

        // Initial UI state
        const sInit = (parseInt(speedRange.value, 10) || 100) / 100;
        speedValue.textContent = `${sInit.toFixed(1)}x`;
        updateUI();
      }

      function updateUI() {
        const recordBtn = document.getElementById('recordBtn');
        const playBtn = document.getElementById('playBtn');
        const stopBtn = document.getElementById('stopBtn');
        const exportBtn = document.getElementById('exportBtn');
        const demoSelect = document.getElementById('demoSelect');
        const speedRange = document.getElementById('speedRange');
        const speedValue = document.getElementById('speedValue');
        const thresholdInput = document.getElementById('thresholdInput');
        
        if (!recorder) return;
        
        const hasEvents = (recorder.getEvents().length > 0) || (loadedEvents && loadedEvents.length > 0);
        const playing = isPlaying;

        // Enable/disable per state
        recordBtn.disabled = playing;
        playBtn.disabled = isRecording || (!hasEvents && !playing);
        stopBtn.disabled = !playing;
        exportBtn.disabled = isRecording || playing || !hasEvents;
        demoSelect.disabled = playing || isRecording;
        speedRange.disabled = playing;
        thresholdInput.disabled = playing;

        // Set play label
        playBtn.textContent = playing ? '‚è∏ Pause' : '‚ñ∂ Play';
      }
    </script>
  </body>
</html>
